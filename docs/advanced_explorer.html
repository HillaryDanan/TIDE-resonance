<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIDE-Resonance Advanced Research Laboratory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --primary: #00ff88;
            --secondary: #ff006e;
            --accent: #3b82f6;
            --warning: #f59e0b;
            --bg-dark: #050505;
            --panel-bg: rgba(10, 10, 10, 0.95);
            --border: rgba(255, 255, 255, 0.1);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-dark);
            color: #fff;
            overflow: hidden;
        }
        
        /* Main Layout */
        .container {
            display: grid;
            grid-template-columns: 350px 1fr 300px;
            grid-template-rows: 60px 1fr 200px;
            height: 100vh;
            gap: 1px;
            background: var(--border);
        }
        
        /* Header */
        .header {
            grid-column: 1 / -1;
            background: var(--panel-bg);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
            border-bottom: 2px solid var(--primary);
        }
        
        .header h1 {
            font-size: 1.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.9rem;
            color: #888;
        }
        
        .status .live {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .live-dot {
            width: 8px;
            height: 8px;
            background: var(--primary);
            border-radius: 50%;
            animation: pulse 2s ease infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.5); }
        }
        
        /* Control Panel */
        .control-panel {
            background: var(--panel-bg);
            overflow-y: auto;
            padding: 1.5rem;
        }
        
        .control-section {
            margin-bottom: 2rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--border);
        }
        
        .control-section:last-child {
            border-bottom: none;
        }
        
        .control-section h3 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .control-group {
            margin-bottom: 1rem;
        }
        
        .control-group label {
            display: block;
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 0.4rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .control-group input[type="range"],
        .control-group select {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 0.5rem;
            border-radius: 6px;
        }
        
        .control-group input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            padding: 0;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .value-display {
            float: right;
            color: var(--primary);
            font-weight: 600;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        button {
            padding: 0.7rem;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--primary);
            color: var(--primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }
        
        button:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-1px);
        }
        
        button.danger {
            background: rgba(255, 0, 110, 0.1);
            border-color: var(--secondary);
            color: var(--secondary);
        }
        
        /* Main Canvas */
        .main-view {
            background: #000;
            position: relative;
        }
        
        #mainCanvas {
            width: 100%;
            height: 100%;
        }
        
        /* Metrics Panel */
        .metrics-panel {
            background: var(--panel-bg);
            padding: 1.5rem;
            overflow-y: auto;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .metric-card h4 {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 0.5rem;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: 600;
            color: var(--primary);
            font-variant-numeric: tabular-nums;
        }
        
        .metric-subtitle {
            font-size: 0.8rem;
            color: #666;
            margin-top: 0.2rem;
        }
        
        .mini-chart {
            width: 100%;
            height: 60px;
            margin-top: 0.5rem;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 4px;
        }
        
        /* Data Panel */
        .data-panel {
            grid-column: 1 / -1;
            background: var(--panel-bg);
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            padding: 1.5rem;
            overflow-x: auto;
        }
        
        .data-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
        }
        
        .data-card h5 {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 0.5rem;
        }
        
        .trust-matrix-mini {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(30px, 1fr));
            gap: 2px;
            margin-top: 0.5rem;
        }
        
        .trust-cell-mini {
            aspect-ratio: 1;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .close-modal {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: 60px auto 1fr auto auto;
            }
            
            .control-panel,
            .metrics-panel {
                grid-column: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>TIDE-Resonance Advanced Research Laboratory</h1>
            <div class="status">
                <div class="live">
                    <div class="live-dot"></div>
                    <span>LIVE SIMULATION</span>
                </div>
                <span id="fps">60 FPS</span>
                <span id="agent-count-status">0 Agents</span>
                <span id="sim-time">00:00</span>
            </div>
        </div>
        
        <!-- Control Panel -->
        <div class="control-panel">
            <div class="control-section">
                <h3>🧬 Architecture Configuration</h3>
                
                <div class="control-group">
                    <label>Population Size <span class="value-display" id="pop-size-value">12</span></label>
                    <input type="range" id="population-size" min="3" max="50" value="12">
                </div>
                
                <div class="control-group">
                    <label>Distribution Model</label>
                    <select id="distribution-model">
                        <option value="balanced">Balanced (Equal Distribution)</option>
                        <option value="nt-dominant">NT Dominant (60/20/20)</option>
                        <option value="asd-dominant">ASD Dominant (20/60/20)</option>
                        <option value="adhd-dominant">ADHD Dominant (20/20/60)</option>
                        <option value="complementary">Complementary Pairs</option>
                        <option value="custom">Custom Distribution</option>
                    </select>
                </div>
                
                <div id="custom-dist" style="display: none;">
                    <div class="control-group">
                        <label>NT % <span class="value-display" id="nt-percent">33%</span></label>
                        <input type="range" id="nt-ratio" min="0" max="100" value="33">
                    </div>
                    <div class="control-group">
                        <label>ASD % <span class="value-display" id="asd-percent">33%</span></label>
                        <input type="range" id="asd-ratio" min="0" max="100" value="33">
                    </div>
                    <div class="control-group">
                        <label>ADHD % <span class="value-display" id="adhd-percent">34%</span></label>
                        <input type="range" id="adhd-ratio" min="0" max="100" value="34">
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>🎵 Environmental Parameters</h3>
                
                <div class="control-group">
                    <label>Music Complexity</label>
                    <select id="music-complexity">
                        <option value="simple">Simple (Single frequency)</option>
                        <option value="structured">Structured (Bach-like)</option>
                        <option value="flowing">Flowing (Debussy-like)</option>
                        <option value="dynamic">Dynamic (EDM-like)</option>
                        <option value="ambient">Ambient (Drone-like)</option>
                        <option value="chaotic">Chaotic (Free jazz)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Tempo (BPM) <span class="value-display" id="tempo-value">120</span></label>
                    <input type="range" id="tempo" min="40" max="200" value="120">
                </div>
                
                <div class="control-group">
                    <label>Sensory Intensity <span class="value-display" id="intensity-value">0.5</span></label>
                    <input type="range" id="sensory-intensity" min="0" max="1" step="0.01" value="0.5">
                </div>
                
                <div class="control-group">
                    <label>Environmental Noise <span class="value-display" id="noise-value">0.1</span></label>
                    <input type="range" id="env-noise" min="0" max="1" step="0.01" value="0.1">
                </div>
                
                <div class="control-group">
                    <label>Lyrics Abstractness <span class="value-display" id="lyrics-value">0.5</span></label>
                    <input type="range" id="lyrics-abstractness" min="0" max="1" step="0.01" value="0.5">
                    <div style="font-size: 0.8rem; color: #666; margin-top: 0.3rem;">
                        <span style="float: left;">Concrete</span>
                        <span style="float: right;">Abstract</span>
                        <div style="clear: both;"></div>
                    </div>
                </div>
                
                <div class="button-group">
                    <button onclick="setLyricsPreset('concrete')">Concrete Sample</button>
                    <button onclick="setLyricsPreset('abstract')">Abstract Sample</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>🤝 Trust Dynamics</h3>
                
                <div class="control-group">
                    <label>Trust Evolution Model</label>
                    <select id="trust-model">
                        <option value="standard">Standard Game Theory</option>
                        <option value="adaptive">Adaptive Learning</option>
                        <option value="memory">Memory-Based</option>
                        <option value="reputation">Reputation Network</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Learning Rate <span class="value-display" id="learning-rate-value">0.1</span></label>
                    <input type="range" id="learning-rate" min="0.01" max="1" step="0.01" value="0.1">
                </div>
                
                <div class="control-group">
                    <label>Memory Decay <span class="value-display" id="memory-decay-value">0.05</span></label>
                    <input type="range" id="memory-decay" min="0" max="0.5" step="0.01" value="0.05">
                </div>
                
                <div class="control-group">
                    <label>Interaction Radius <span class="value-display" id="radius-value">150px</span></label>
                    <input type="range" id="interaction-radius" min="50" max="500" value="150">
                </div>
            </div>
            
            <div class="control-section">
                <h3>🔬 Dimensional Analysis</h3>
                
                <div class="control-group">
                    <label>Self-Dimension Weight <span class="value-display" id="self-dim-value">0.0</span></label>
                    <input type="range" id="self-dimension" min="-1" max="1" step="0.01" value="0">
                </div>
                
                <div class="control-group">
                    <label>Time-Dimension Weight <span class="value-display" id="time-dim-value">0.0</span></label>
                    <input type="range" id="time-dimension" min="-1" max="1" step="0.01" value="0">
                </div>
                
                <div class="control-group">
                    <label>Integration Function</label>
                    <select id="integration-function">
                        <option value="multiplicative">Multiplicative</option>
                        <option value="additive">Additive</option>
                        <option value="hierarchical">Hierarchical</option>
                        <option value="quantum">Quantum Superposition</option>
                    </select>
                </div>
            </div>
            
            <div class="button-group">
                <button onclick="resetSimulation()">Reset</button>
                <button onclick="pauseSimulation()">Pause</button>
                <button onclick="saveState()">Save State</button>
                <button onclick="loadState()">Load State</button>
                <button onclick="exportData()">Export Data</button>
                <button onclick="showHelp()">Help</button>
            </div>
        </div>
        
        <!-- Main Canvas -->
        <div class="main-view">
            <canvas id="mainCanvas"></canvas>
        </div>
        
        <!-- Metrics Panel -->
        <div class="metrics-panel">
            <h3 style="margin-bottom: 1rem; color: var(--primary);">📊 Live Metrics</h3>
            
            <div class="metric-card">
                <h4>System Trust</h4>
                <div class="metric-value" id="system-trust">0.000</div>
                <div class="metric-subtitle">Cross-architecture average</div>
                <canvas class="mini-chart" id="trust-chart"></canvas>
            </div>
            
            <div class="metric-card">
                <h4>Collective Resonance</h4>
                <div class="metric-value" id="collective-resonance">0.000</div>
                <div class="metric-subtitle">System-wide coherence</div>
                <canvas class="mini-chart" id="resonance-chart"></canvas>
            </div>
            
            <div class="metric-card">
                <h4>Diversity Index</h4>
                <div class="metric-value" id="diversity-index">0.000</div>
                <div class="metric-subtitle">Shannon entropy</div>
            </div>
            
            <div class="metric-card">
                <h4>Stability Score</h4>
                <div class="metric-value" id="stability-score">0.000</div>
                <div class="metric-subtitle">System equilibrium</div>
            </div>
            
            <div class="metric-card">
                <h4>Information Flow</h4>
                <div class="metric-value" id="info-flow">0.000</div>
                <div class="metric-subtitle">bits/second</div>
            </div>
        </div>
        
        <!-- Data Panel -->
        <div class="data-panel">
            <div class="data-card">
                <h5>Trust Matrix</h5>
                <div class="trust-matrix-mini" id="trust-matrix-display"></div>
            </div>
            
            <div class="data-card">
                <h5>Architecture Distribution</h5>
                <canvas id="distribution-chart" width="200" height="100"></canvas>
            </div>
            
            <div class="data-card">
                <h5>Resonance Heatmap</h5>
                <canvas id="resonance-heatmap" width="200" height="120"></canvas>
            </div>
            
            <div class="data-card">
                <h5>Network Topology</h5>
                <div id="network-stats">
                    <div>Clusters: <span id="cluster-count">0</span></div>
                    <div>Bridges: <span id="bridge-count">0</span></div>
                    <div>Isolates: <span id="isolate-count">0</span></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div class="modal" id="help-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Research Laboratory Guide</h2>
                <button class="close-modal" onclick="closeHelp()">&times;</button>
            </div>
            <div class="modal-body">
                <h3>Architecture Types</h3>
                <ul>
                    <li><strong>NT (Blue)</strong>: Balanced processing, moderate trust formation</li>
                    <li><strong>ASD (Orange)</strong>: Systematic processing, careful trust building</li>
                    <li><strong>ADHD (Red)</strong>: Dynamic processing, rapid trust changes</li>
                </ul>
                
                <h3>Visual Indicators</h3>
                <ul>
                    <li><strong>Connection Lines</strong>: Trust strength between agents</li>
                    <li><strong>Pulse Size</strong>: Current resonance with environment</li>
                    <li><strong>Movement Pattern</strong>: Architecture-specific behavior</li>
                </ul>
                
                <h3>Key Metrics</h3>
                <ul>
                    <li><strong>System Trust</strong>: Average trust across all relationships</li>
                    <li><strong>Collective Resonance</strong>: How well the system synchronizes</li>
                    <li><strong>Diversity Index</strong>: Variety in the population</li>
                </ul>
                
                <h3>Lyrics Response</h3>
                <ul>
                    <li><strong>NT</strong>: Prefers balanced lyrics (mid-range abstractness)</li>
                    <li><strong>ASD</strong>: Prefers concrete, literal lyrics</li>
                    <li><strong>ADHD</strong>: Prefers abstract, novel lyrics</li>
                </ul>
                
                <p style="margin-top: 1rem; color: #888;">
                    This is a theoretical research simulation. All parameters are hypothetical
                    and designed for scientific exploration.
                </p>
            </div>
        </div>
    </div>
    
    <script>
        // Get canvas and context
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        // Mini chart contexts
        const trustChartCanvas = document.getElementById('trust-chart');
        const trustChartCtx = trustChartCanvas.getContext('2d');
        const resonanceChartCanvas = document.getElementById('resonance-chart');
        const resonanceChartCtx = resonanceChartCanvas.getContext('2d');
        
        // Resize canvas
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // Resize mini charts
            trustChartCanvas.width = trustChartCanvas.offsetWidth;
            trustChartCanvas.height = 60;
            resonanceChartCanvas.width = resonanceChartCanvas.offsetWidth;
            resonanceChartCanvas.height = 60;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Architecture configurations
        const ARCHITECTURES = {
            NT: {
                color: '#3b82f6',
                glow: 'rgba(59, 130, 246, 0.4)',
                params: {
                    initialTrust: 0.5,
                    learningRate: 0.1,
                    decayRate: 0.05,
                    resonanceThreshold: 0.6,
                    movementStyle: 'smooth',
                    socialDistance: 80,
                    musicResponse: {
                        simple: 0.6,
                        structured: 0.7,
                        flowing: 0.8,
                        dynamic: 0.6,
                        ambient: 0.5,
                        chaotic: 0.3
                    }
                }
            },
            ASD: {
                color: '#f59e0b',
                glow: 'rgba(245, 158, 11, 0.4)',
                params: {
                    initialTrust: 0.3,
                    learningRate: 0.15,
                    decayRate: 0.02,
                    resonanceThreshold: 0.8,
                    movementStyle: 'systematic',
                    socialDistance: 120,
                    musicResponse: {
                        simple: 0.8,
                        structured: 0.9,
                        flowing: 0.4,
                        dynamic: 0.3,
                        ambient: 0.7,
                        chaotic: 0.1
                    }
                }
            },
            ADHD: {
                color: '#ef4444',
                glow: 'rgba(239, 68, 68, 0.4)',
                params: {
                    initialTrust: 0.7,
                    learningRate: 0.2,
                    decayRate: 0.1,
                    resonanceThreshold: 0.4,
                    movementStyle: 'dynamic',
                    socialDistance: 60,
                    musicResponse: {
                        simple: 0.4,
                        structured: 0.3,
                        flowing: 0.6,
                        dynamic: 0.9,
                        ambient: 0.4,
                        chaotic: 0.8
                    }
                }
            }
        };
        
        // Agent class
        class Agent {
            constructor(id, type, x, y) {
                this.id = id;
                this.type = type;
                this.config = ARCHITECTURES[type];
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.angle = Math.random() * Math.PI * 2;
                this.radius = 20;
                this.energy = 1;
                this.resonance = 0;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.trustMatrix = {};
                this.interactionHistory = [];
                this.memory = [];
            }
            
            update(agents, params) {
                this.updateMovement(agents, params);
                this.updateResonance(params);
                this.updateTrust(agents, params);
                this.updateEnergy();
            }
            
            updateMovement(agents, params) {
                const style = this.config.params.movementStyle;
                
                if (style === 'smooth') {
                    this.angle += (Math.random() - 0.5) * 0.1;
                    const speed = 1.5 * (1 + params.sensoryIntensity * 0.5);
                    this.vx = Math.cos(this.angle) * speed;
                    this.vy = Math.sin(this.angle) * speed;
                } else if (style === 'systematic') {
                    if (Math.random() < 0.02) {
                        this.angle = Math.round(this.angle / (Math.PI/2)) * (Math.PI/2);
                    }
                    const speed = 1.2;
                    this.vx = Math.cos(this.angle) * speed;
                    this.vy = Math.sin(this.angle) * speed;
                } else if (style === 'dynamic') {
                    this.angle += (Math.random() - 0.5) * 0.3 * (1 + params.sensoryIntensity);
                    const speed = 2.5 * (1 + params.sensoryIntensity * 0.3);
                    this.vx = Math.cos(this.angle) * speed;
                    this.vy = Math.sin(this.angle) * speed;
                }
                
                // Social forces
                agents.forEach(other => {
                    if (other.id !== this.id) {
                        const dx = other.x - this.x;
                        const dy = other.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < this.config.params.socialDistance && dist > 0) {
                            const force = (this.config.params.socialDistance - dist) / this.config.params.socialDistance;
                            this.vx -= (dx / dist) * force * 0.5;
                            this.vy -= (dy / dist) * force * 0.5;
                        }
                        
                        // Attraction to trusted agents
                        if (this.trustMatrix[other.id] > 0.6 && dist > 100) {
                            this.vx += (dx / dist) * this.trustMatrix[other.id] * 0.2;
                            this.vy += (dy / dist) * this.trustMatrix[other.id] * 0.2;
                        }
                    }
                });
                
                // Apply noise
                if (params.envNoise > 0) {
                    this.vx += (Math.random() - 0.5) * params.envNoise * 2;
                    this.vy += (Math.random() - 0.5) * params.envNoise * 2;
                }
                
                // Update position
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.x += this.vx;
                this.y += this.vy;
                
                // Boundaries
                const margin = this.radius + 10;
                if (this.x < margin) this.x = margin, this.vx = Math.abs(this.vx);
                if (this.x > canvas.width - margin) this.x = canvas.width - margin, this.vx = -Math.abs(this.vx);
                if (this.y < margin) this.y = margin, this.vy = Math.abs(this.vy);
                if (this.y > canvas.height - margin) this.y = canvas.height - margin, this.vy = -Math.abs(this.vy);
            }
            
            updateResonance(params) {
                const baseResonance = this.config.params.musicResponse[params.musicComplexity];
                const tempoFactor = 1 - Math.abs(params.tempo - 100) / 100 * 0.5;
                const dimensionalModifier = this.calculateDimensionalModifier(params);
                
                this.resonance = baseResonance * tempoFactor * params.sensoryIntensity * dimensionalModifier;
                
                // Apply lyrics modifier based on architecture preference
                if (params.lyricsAbstractness !== undefined) {
                    let lyricsModifier = 1;
                    
                    // NT: Balanced - prefers mid-range abstractness
                    if (this.type === "NT") {
                        // Peak at 0.5, falls off towards extremes
                        lyricsModifier = 0.7 + 0.6 * (1 - Math.abs(0.5 - params.lyricsAbstractness) * 2);
                    }
                    // ASD: Systematic - prefers concrete lyrics (low abstractness)
                    else if (this.type === "ASD") {
                        // Higher resonance with lower abstractness
                        lyricsModifier = 0.6 + 0.8 * (1 - params.lyricsAbstractness);
                    }
                    // ADHD: Dynamic - prefers abstract/novel lyrics (high abstractness)
                    else if (this.type === "ADHD") {
                        // Higher resonance with higher abstractness
                        lyricsModifier = 0.6 + 0.8 * params.lyricsAbstractness;
                    }
                    
                    this.resonance *= lyricsModifier;
                }
                
                this.pulsePhase += this.resonance * 0.1;
            }
            
            calculateDimensionalModifier(params) {
                const selfMod = {
                    NT: 0.5 + params.selfDimension * 0.3,
                    ASD: 0.3 + params.selfDimension * 0.5,
                    ADHD: 0.7 + params.selfDimension * 0.2
                };
                
                const timeMod = {
                    NT: 0.5 + params.timeDimension * 0.3,
                    ASD: 0.7 + params.timeDimension * 0.2,
                    ADHD: 0.3 + params.timeDimension * 0.5
                };
                
                if (params.integrationFunction === 'multiplicative') {
                    return selfMod[this.type] * timeMod[this.type];
                } else if (params.integrationFunction === 'additive') {
                    return (selfMod[this.type] + timeMod[this.type]) / 2;
                } else if (params.integrationFunction === 'hierarchical') {
                    return Math.max(selfMod[this.type], timeMod[this.type]);
                } else { // quantum
                    return Math.sqrt(selfMod[this.type] * selfMod[this.type] + timeMod[this.type] * timeMod[this.type]) / Math.sqrt(2);
                }
            }
            
            updateTrust(agents, params) {
                agents.forEach(other => {
                    if (other.id !== this.id) {
                        const dist = Math.sqrt(
                            Math.pow(this.x - other.x, 2) + 
                            Math.pow(this.y - other.y, 2)
                        );
                        
                        if (dist < params.interactionRadius) {
                            if (!this.trustMatrix[other.id]) {
                                this.trustMatrix[other.id] = this.config.params.initialTrust;
                            }
                            
                            const proximity = 1 - dist / params.interactionRadius;
                            const resonanceMatch = 1 - Math.abs(this.resonance - other.resonance);
                            const architectureBonus = this.getArchitectureCompatibility(other.type);
                            
                            const quality = proximity * resonanceMatch * architectureBonus;
                            const currentTrust = this.trustMatrix[other.id];
                            
                            let newTrust = currentTrust;
                            
                            if (params.trustModel === 'standard') {
                                const success = quality > this.config.params.resonanceThreshold ? 1 : 0;
                                const delta = params.learningRate * (success - currentTrust);
                                const decay = -params.memoryDecay * (currentTrust - this.config.params.initialTrust);
                                newTrust = currentTrust + delta + decay;
                            } else if (params.trustModel === 'adaptive') {
                                const adaptiveRate = params.learningRate * (1 - currentTrust);
                                newTrust = currentTrust + quality * adaptiveRate;
                            } else if (params.trustModel === 'memory') {
                                this.memory.push({ agent: other.id, quality, time: Date.now() });
                                if (this.memory.length > 10) this.memory.shift();
                                const avgQuality = this.memory
                                    .filter(m => m.agent === other.id)
                                    .reduce((sum, m) => sum + m.quality, 0) / this.memory.filter(m => m.agent === other.id).length;
                                newTrust = currentTrust * (1 - params.learningRate) + avgQuality * params.learningRate;
                            } else if (params.trustModel === 'reputation') {
                                const reputation = this.calculateReputation(other, agents);
                                newTrust = currentTrust * 0.7 + reputation * 0.3;
                            }
                            
                            this.trustMatrix[other.id] = Math.max(0, Math.min(1, newTrust));
                            
                            this.interactionHistory.push({
                                time: Date.now(),
                                agent: other.id,
                                trust: this.trustMatrix[other.id],
                                quality
                            });
                            
                            if (this.interactionHistory.length > 100) {
                                this.interactionHistory.shift();
                            }
                        }
                    }
                });
            }
            
            getArchitectureCompatibility(otherType) {
                const compatibility = {
                    NT: { NT: 0.8, ASD: 0.6, ADHD: 0.7 },
                    ASD: { NT: 0.6, ASD: 0.9, ADHD: 0.4 },
                    ADHD: { NT: 0.7, ASD: 0.4, ADHD: 0.8 }
                };
                return compatibility[this.type][otherType];
            }
            
            calculateReputation(agent, allAgents) {
                let totalTrust = 0;
                let count = 0;
                
                allAgents.forEach(other => {
                    if (other.id !== this.id && other.id !== agent.id && other.trustMatrix[agent.id]) {
                        totalTrust += other.trustMatrix[agent.id];
                        count++;
                    }
                });
                
                return count > 0 ? totalTrust / count : 0.5;
            }
            
            updateEnergy() {
                this.energy = 0.9 * this.energy + 0.1 * this.resonance;
            }
            
            draw(ctx, agents) {
                // Draw trust connections
                agents.forEach(other => {
                    if (other.id > this.id && this.trustMatrix[other.id] && other.trustMatrix[this.id]) {
                        const trust = (this.trustMatrix[other.id] + other.trustMatrix[this.id]) / 2;
                        
                        if (trust > 0.2) {
                            const gradient = ctx.createLinearGradient(this.x, this.y, other.x, other.y);
                            gradient.addColorStop(0, this.config.color + Math.floor(trust * 127).toString(16).padStart(2, '0'));
                            gradient.addColorStop(1, other.config.color + Math.floor(trust * 127).toString(16).padStart(2, '0'));
                            
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = trust * 4;
                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y);
                            ctx.lineTo(other.x, other.y);
                            ctx.stroke();
                        }
                    }
                });
                
                // Draw resonance field
                const pulse = Math.sin(this.pulsePhase) * 15 * this.resonance;
                const fieldRadius = this.radius + 30 + pulse;
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, this.radius,
                    this.x, this.y, fieldRadius
                );
                gradient.addColorStop(0, this.config.glow);
                gradient.addColorStop(0.5, this.config.glow.replace('0.4', '0.2'));
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, fieldRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw agent body
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.config.color;
                ctx.fillStyle = this.config.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Energy ring
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2 * this.energy);
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                // Type label
                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.type, this.x, this.y);
            }
        }
        
        // Simulation state
        let agents = [];
        let paused = false;
        let simulationTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let fps = 60;
        let params = {
            populationSize: 12,
            distributionModel: 'balanced',
            musicComplexity: 'structured',
            tempo: 120,
            sensoryIntensity: 0.5,
            envNoise: 0.1,
            trustModel: 'standard',
            learningRate: 0.1,
            memoryDecay: 0.05,
            interactionRadius: 150,
            selfDimension: 0,
            timeDimension: 0,
            integrationFunction: 'multiplicative',
            lyricsAbstractness: 0.5
        };
        
        // Parameter change tracking for visual feedback
        let paramChanges = {};
        let previousParams = JSON.parse(JSON.stringify(params));
        
        function trackParameterChange(paramName, newValue) {
            if (previousParams[paramName] !== newValue) {
                paramChanges[paramName] = {
                    time: Date.now(),
                    oldValue: previousParams[paramName],
                    newValue: newValue
                };
                previousParams[paramName] = newValue;
                
                // Flash the metric cards when parameters change
                flashMetrics();
            }
        }
        
        function flashMetrics() {
            const cards = document.querySelectorAll('.metric-card');
            cards.forEach(card => {
                card.style.transition = 'all 0.3s';
                card.style.boxShadow = '0 0 20px rgba(0, 255, 136, 0.5)';
                setTimeout(() => {
                    card.style.boxShadow = '';
                }, 300);
            });
        }
        
        // History for charts
        let trustHistory = [];
        let resonanceHistory = [];
        
        // Initialize simulation
        function initSimulation() {
            agents = [];
            const distribution = getDistribution();
            
            for (let i = 0; i < params.populationSize; i++) {
                const type = distribution[i % distribution.length];
                const angle = (i / params.populationSize) * Math.PI * 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.3;
                const x = canvas.width / 2 + Math.cos(angle) * radius * (0.8 + Math.random() * 0.4);
                const y = canvas.height / 2 + Math.sin(angle) * radius * (0.8 + Math.random() * 0.4);
                agents.push(new Agent(i, type, x, y));
            }
            
            trustHistory = [];
            resonanceHistory = [];
            simulationTime = 0;
        }
        
        function getDistribution() {
            switch(params.distributionModel) {
                case 'balanced': return ['NT', 'ASD', 'ADHD'];
                case 'nt-dominant': return ['NT', 'NT', 'NT', 'ASD', 'ADHD'];
                case 'asd-dominant': return ['ASD', 'ASD', 'ASD', 'NT', 'ADHD'];
                case 'adhd-dominant': return ['ADHD', 'ADHD', 'ADHD', 'NT', 'ASD'];
                case 'complementary': return ['NT', 'ASD', 'NT', 'ASD'];
                case 'custom': {
                    const dist = [];
                    const ntCount = Math.round(params.populationSize * params.ntRatio / 100);
                    const asdCount = Math.round(params.populationSize * params.asdRatio / 100);
                    const adhdCount = params.populationSize - ntCount - asdCount;
                    
                    for (let i = 0; i < ntCount; i++) dist.push('NT');
                    for (let i = 0; i < asdCount; i++) dist.push('ASD');
                    for (let i = 0; i < adhdCount; i++) dist.push('ADHD');
                    
                    return dist.sort(() => Math.random() - 0.5);
                }
                default: return ['NT', 'ASD', 'ADHD'];
            }
        }
        
        // Update metrics
        function updateMetrics() {
            // Calculate metrics
            let totalTrust = 0;
            let trustCount = 0;
            let totalResonance = 0;
            const typeCounts = { NT: 0, ASD: 0, ADHD: 0 };
            
            agents.forEach(agent => {
                typeCounts[agent.type]++;
                totalResonance += agent.resonance;
                
                Object.values(agent.trustMatrix).forEach(trust => {
                    totalTrust += trust;
                    trustCount++;
                });
            });
            
            const systemTrust = trustCount > 0 ? totalTrust / trustCount : 0;
            const collectiveResonance = totalResonance / agents.length;
            
            // Diversity index (Shannon entropy)
            let diversityIndex = 0;
            Object.values(typeCounts).forEach(count => {
                if (count > 0) {
                    const p = count / agents.length;
                    diversityIndex -= p * Math.log(p);
                }
            });
            diversityIndex = Math.exp(diversityIndex) / 3;
            
            // Stability score
            const trustVariance = agents.reduce((sum, agent) => {
                const agentAvg = Object.values(agent.trustMatrix).reduce((s, t) => s + t, 0) / 
                                Math.max(1, Object.values(agent.trustMatrix).length);
                return sum + Math.pow(agentAvg - systemTrust, 2);
            }, 0) / agents.length;
            const stabilityScore = 1 - Math.min(1, Math.sqrt(trustVariance));
            
            // Information flow (interactions per second)
            const recentInteractions = agents.reduce((sum, agent) => {
                return sum + agent.interactionHistory.filter(i => Date.now() - i.time < 1000).length;
            }, 0);
            const infoFlow = recentInteractions / agents.length;
            
            // Update displays
            document.getElementById('system-trust').textContent = systemTrust.toFixed(3);
            document.getElementById('collective-resonance').textContent = collectiveResonance.toFixed(3);
            document.getElementById('diversity-index').textContent = diversityIndex.toFixed(3);
            document.getElementById('stability-score').textContent = stabilityScore.toFixed(3);
            document.getElementById('info-flow').textContent = infoFlow.toFixed(3);
            
            // Update history
            trustHistory.push(systemTrust);
            resonanceHistory.push(collectiveResonance);
            if (trustHistory.length > 100) trustHistory.shift();
            if (resonanceHistory.length > 100) resonanceHistory.shift();
            
            // Update mini charts
            drawMiniChart(trustChartCtx, trustHistory, '#00ff88');
            drawMiniChart(resonanceChartCtx, resonanceHistory, '#3b82f6');
            
            // Update network stats
            updateNetworkStats();
            
            // Update distribution chart
            updateDistributionChart(typeCounts);
            
            // Update trust matrix and resonance heatmap
            updateTrustMatrixDisplay();
            updateResonanceHeatmap();
        }
        
        function drawMiniChart(ctx, data, color) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            if (data.length < 2) return;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            data.forEach((value, i) => {
                const x = (i / (data.length - 1)) * ctx.canvas.width;
                const y = ctx.canvas.height - value * ctx.canvas.height * 0.9 - 5;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            
            ctx.stroke();
        }
        
        function updateNetworkStats() {
            let clusters = 0;
            let bridges = 0;
            let isolates = 0;
            
            // Simple network analysis
            const visited = new Set();
            
            agents.forEach(agent => {
                const strongConnections = Object.entries(agent.trustMatrix)
                    .filter(([id, trust]) => trust > 0.5).length;
                
                if (strongConnections === 0) isolates++;
                else if (strongConnections === 1) bridges++;
                else if (strongConnections > 3 && !visited.has(agent.id)) {
                    clusters++;
                    visited.add(agent.id);
                }
            });
            
            document.getElementById('cluster-count').textContent = clusters;
            document.getElementById('bridge-count').textContent = bridges;
            document.getElementById('isolate-count').textContent = isolates;
        }
        
        function updateDistributionChart(typeCounts) {
            const ctx = document.getElementById('distribution-chart').getContext('2d');
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const total = agents.length;
            let x = 0;
            
            ['NT', 'ASD', 'ADHD'].forEach(type => {
                const count = typeCounts[type];
                const barWidth = (count / total) * width;
                
                ctx.fillStyle = ARCHITECTURES[type].color;
                ctx.fillRect(x, 0, barWidth, height);
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(count, x + barWidth / 2, height / 2 + 4);
                
                x += barWidth;
            });
        }
        
        
        // Update trust matrix display
        function updateTrustMatrixDisplay() {
            const matrixDiv = document.getElementById('trust-matrix-display');
            matrixDiv.innerHTML = '';
            
            // Only show for reasonable number of agents
            if (agents.length <= 12) {
                agents.forEach((agent, i) => {
                    agents.forEach((other, j) => {
                        if (i !== j) {
                            const trust = agent.trustMatrix[other.id] || 0;
                            const cell = document.createElement('div');
                            cell.className = 'trust-cell-mini';
                            cell.style.background = `rgba(0, 255, 136, ${trust})`;
                            cell.style.color = trust > 0.5 ? '#000' : '#fff';
                            cell.style.fontSize = '10px';
                            cell.textContent = trust.toFixed(1);
                            cell.title = `${agent.type}→${other.type}: ${trust.toFixed(2)}`;
                            matrixDiv.appendChild(cell);
                        }
                    });
                });
            } else {
                matrixDiv.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">Too many agents</div>';
            }
        }

        // Update resonance heatmap
        function updateResonanceHeatmap() {
            const ctx = document.getElementById('resonance-heatmap').getContext('2d');
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            if (agents.length === 0) return;
            
            // Find min and max resonance for auto-scaling
            let minRes = agents[0].resonance;
            let maxRes = agents[0].resonance;
            agents.forEach(agent => {
                minRes = Math.min(minRes, agent.resonance);
                maxRes = Math.max(maxRes, agent.resonance);
            });
            
            // Ensure we have a range to work with
            const range = maxRes - minRes;
            if (range < 0.001) {
                // If all values are very similar, expand the range
                minRes = Math.max(0, minRes - 0.05);
                maxRes = Math.min(1, maxRes + 0.05);
            }
            
            // Create grid
            const gridSize = Math.ceil(Math.sqrt(agents.length));
            const cellWidth = width / gridSize;
            const cellHeight = (height - 15) / gridSize; // Leave space for legend
            
            agents.forEach((agent, i) => {
                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                const x = col * cellWidth;
                const y = row * cellHeight;
                
                // Normalize resonance to 0-1 range
                const normalizedRes = (agent.resonance - minRes) / (maxRes - minRes || 1);
                
                // Use agent's color with brightness based on normalized resonance
                const baseColor = agent.config.color;
                const r = parseInt(baseColor.slice(1,3), 16);
                const g = parseInt(baseColor.slice(3,5), 16);
                const b = parseInt(baseColor.slice(5,7), 16);
                
                // Create gradient from dark to bright
                const intensity = 0.2 + (normalizedRes * 0.8);
                
                // Fill cell with gradient
                const cellGradient = ctx.createLinearGradient(x, y, x + cellWidth, y + cellHeight);
                cellGradient.addColorStop(0, `rgba(${r*intensity}, ${g*intensity}, ${b*intensity}, 0.9)`);
                cellGradient.addColorStop(1, `rgba(${r*intensity*0.7}, ${g*intensity*0.7}, ${b*intensity*0.7}, 0.9)`);
                ctx.fillStyle = cellGradient;
                ctx.fillRect(x + 1, y + 1, cellWidth - 2, cellHeight - 2);
                
                // Add subtle border
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
                ctx.lineWidth = 1;
                ctx.strokeRect(x + 0.5, y + 0.5, cellWidth - 1, cellHeight - 1);
                
                // Add crisp white text with dark outline for readability
                ctx.save();
                
                // Draw dark outline for contrast
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeText(agent.type, x + cellWidth/2, y + cellHeight/2 - 6);
                
                ctx.font = '10px Arial';
                ctx.strokeText(agent.resonance.toFixed(3), x + cellWidth/2, y + cellHeight/2 + 6);
                
                // Draw white text on top
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 11px Arial';
                ctx.fillText(agent.type, x + cellWidth/2, y + cellHeight/2 - 6);
                
                ctx.font = '10px Arial';
                ctx.fillText(agent.resonance.toFixed(3), x + cellWidth/2, y + cellHeight/2 + 6);
                
                ctx.restore();
            });
            
            // Add color scale legend
            ctx.fillStyle = '#666';
            ctx.font = '9px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Min: ${minRes.toFixed(3)}`, 5, height - 5);
            ctx.textAlign = 'center';
            ctx.fillText(`Range: ${(maxRes - minRes).toFixed(3)}`, width/2, height - 5);
            ctx.textAlign = 'right';
            ctx.fillText(`Max: ${maxRes.toFixed(3)}`, width - 5, height - 5);
        }
        
        // Add parameter impact display
        function showParameterImpact() {
            const impactDiv = document.createElement('div');
            impactDiv.style.position = 'fixed';
            impactDiv.style.bottom = '20px';
            impactDiv.style.right = '20px';
            impactDiv.style.background = 'rgba(0, 0, 0, 0.9)';
            impactDiv.style.border = '1px solid var(--primary)';
            impactDiv.style.borderRadius = '8px';
            impactDiv.style.padding = '10px';
            impactDiv.style.color = '#fff';
            impactDiv.style.fontSize = '12px';
            impactDiv.style.zIndex = '500';
            
            const changes = Object.entries(paramChanges).filter(([k, v]) => Date.now() - v.time < 3000);
            if (changes.length > 0) {
                impactDiv.innerHTML = '<strong>Recent Changes:</strong><br>' +
                    changes.map(([k, v]) => `${k}: ${v.oldValue} → ${v.newValue}`).join('<br>');
                document.body.appendChild(impactDiv);
                setTimeout(() => impactDiv.remove(), 3000);
            }
        }
        
        setInterval(showParameterImpact, 1000);

        // Animation loop
        function animate() {
            if (!paused) {
                // Clear canvas
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Update agents
                agents.forEach(agent => {
                    agent.update(agents, params);
                });
                
                // Draw agents
                agents.forEach(agent => {
                    agent.draw(ctx, agents);
                });
                
                // Update metrics every 10 frames
                if (frameCount % 10 === 0) {
                    updateMetrics();
                }
                
                // Update FPS
                frameCount++;
                const now = Date.now();
                if (now - lastFpsUpdate > 1000) {
                    fps = frameCount;
                    frameCount = 0;
                    lastFpsUpdate = now;
                    document.getElementById('fps').textContent = fps + ' FPS';
                }
                
                // Update simulation time
                simulationTime++;
                const minutes = Math.floor(simulationTime / 3600);
                const seconds = Math.floor((simulationTime % 3600) / 60);
                document.getElementById('sim-time').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                document.getElementById('agent-count-status').textContent = agents.length + ' Agents';
            }
            
            requestAnimationFrame(animate);
        }
        
        // Control functions
        function resetSimulation() {
            initSimulation();
        }
        
        function pauseSimulation() {
            paused = !paused;
        }
        
        function saveState() {
            const state = {
                params: params,
                agents: agents.map(a => ({
                    id: a.id,
                    type: a.type,
                    position: { x: a.x, y: a.y },
                    trustMatrix: a.trustMatrix
                })),
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('tide-resonance-state', JSON.stringify(state));
            alert('State saved!');
        }
        
        function loadState() {
            const saved = localStorage.getItem('tide-resonance-state');
            if (saved) {
                const state = JSON.parse(saved);
                params = state.params;
                // Restore controls
                updateControlsFromParams();
                initSimulation();
                alert('State loaded!');
            } else {
                alert('No saved state found');
            }
        }
        
        function exportData() {
            const data = {
                metadata: {
                    timestamp: new Date().toISOString(),
                    simulationTime: simulationTime,
                    fps: fps,
                    version: '2.0'
                },
                parameters: params,
                agents: agents.map(agent => ({
                    id: agent.id,
                    type: agent.type,
                    position: { x: agent.x, y: agent.y },
                    velocity: { x: agent.vx, y: agent.vy },
                    resonance: agent.resonance,
                    energy: agent.energy,
                    trustMatrix: agent.trustMatrix,
                    interactionHistory: agent.interactionHistory
                })),
                metrics: {
                    systemTrust: parseFloat(document.getElementById('system-trust').textContent),
                    collectiveResonance: parseFloat(document.getElementById('collective-resonance').textContent),
                    diversityIndex: parseFloat(document.getElementById('diversity-index').textContent),
                    stabilityScore: parseFloat(document.getElementById('stability-score').textContent),
                    infoFlow: parseFloat(document.getElementById('info-flow').textContent)
                },
                history: {
                    trust: trustHistory,
                    resonance: resonanceHistory
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tide_resonance_advanced_${Date.now()}.json`;
            a.click();
        }
        
        function showHelp() {
            document.getElementById('help-modal').style.display = 'flex';
        }
        
        function closeHelp() {
            document.getElementById('help-modal').style.display = 'none';
        }
        
        function updateControlsFromParams() {
            // Update all controls to match params
            document.getElementById('population-size').value = params.populationSize;
            document.getElementById('distribution-model').value = params.distributionModel;
            document.getElementById('lyrics-abstractness').value = params.lyricsAbstractness;
            document.getElementById('lyrics-value').textContent = params.lyricsAbstractness.toFixed(2);
            // ... etc for all controls
        }
        
        // Event listeners
        document.getElementById('population-size').addEventListener('input', (e) => {
            params.populationSize = parseInt(e.target.value);
            document.getElementById('pop-size-value').textContent = params.populationSize;
            initSimulation();
        });
        
        document.getElementById('distribution-model').addEventListener('change', (e) => {
            params.distributionModel = e.target.value;
            document.getElementById('custom-dist').style.display = 
                e.target.value === 'custom' ? 'block' : 'none';
            initSimulation();
        });
        
        document.getElementById('music-complexity').addEventListener('change', (e) => {
            params.musicComplexity = e.target.value;
            trackParameterChange('musicComplexity', e.target.value);
            // Show immediate effect
            agents.forEach(agent => {
                const flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.left = agent.x + 'px';
                flash.style.top = agent.y + 'px';
                flash.style.color = agent.config.color;
                flash.style.pointerEvents = 'none';
                flash.style.fontSize = '12px';
                flash.style.fontWeight = 'bold';
                flash.textContent = agent.config.params.musicResponse[e.target.value].toFixed(2);
                canvas.parentElement.appendChild(flash);
                setTimeout(() => flash.remove(), 1000);
            });
        });
        
        document.getElementById('tempo').addEventListener('input', (e) => {
            params.tempo = parseInt(e.target.value);
            document.getElementById('tempo-value').textContent = params.tempo;
        });
        
        document.getElementById('sensory-intensity').addEventListener('input', (e) => {
            params.sensoryIntensity = parseFloat(e.target.value);
            trackParameterChange('sensoryIntensity', params.sensoryIntensity);
            document.getElementById('intensity-value').textContent = params.sensoryIntensity.toFixed(2);
        });
        
        document.getElementById('env-noise').addEventListener('input', (e) => {
            params.envNoise = parseFloat(e.target.value);
            document.getElementById('noise-value').textContent = params.envNoise.toFixed(2);
        });
        
        document.getElementById('trust-model').addEventListener('change', (e) => {
            params.trustModel = e.target.value;
        });
        
        document.getElementById('learning-rate').addEventListener('input', (e) => {
            params.learningRate = parseFloat(e.target.value);
            document.getElementById('learning-rate-value').textContent = params.learningRate.toFixed(2);
        });
        
        document.getElementById('memory-decay').addEventListener('input', (e) => {
            params.memoryDecay = parseFloat(e.target.value);
            document.getElementById('memory-decay-value').textContent = params.memoryDecay.toFixed(2);
        });
        
        document.getElementById('interaction-radius').addEventListener('input', (e) => {
            params.interactionRadius = parseInt(e.target.value);
            document.getElementById('radius-value').textContent = params.interactionRadius + 'px';
        });
        
        document.getElementById('self-dimension').addEventListener('input', (e) => {
            params.selfDimension = parseFloat(e.target.value);
            document.getElementById('self-dim-value').textContent = params.selfDimension.toFixed(2);
        });
        
        document.getElementById('time-dimension').addEventListener('input', (e) => {
            params.timeDimension = parseFloat(e.target.value);
            document.getElementById('time-dim-value').textContent = params.timeDimension.toFixed(2);
        });
        
        document.getElementById('integration-function').addEventListener('change', (e) => {
            params.integrationFunction = e.target.value;
        });
        
        // Custom distribution controls
        document.getElementById('nt-ratio').addEventListener('input', (e) => {
            params.ntRatio = parseInt(e.target.value);
            document.getElementById('nt-percent').textContent = params.ntRatio + '%';
            
            // Adjust ADHD to keep total at 100%
            const remaining = 100 - params.ntRatio - params.asdRatio;
            params.adhdRatio = Math.max(0, remaining);
            document.getElementById('adhd-ratio').value = params.adhdRatio;
            document.getElementById('adhd-percent').textContent = params.adhdRatio + '%';
            
            if (params.distributionModel === 'custom') initSimulation();
        });
        
        document.getElementById('asd-ratio').addEventListener('input', (e) => {
            params.asdRatio = parseInt(e.target.value);
            document.getElementById('asd-percent').textContent = params.asdRatio + '%';
            
            // Adjust ADHD to keep total at 100%
            const remaining = 100 - params.ntRatio - params.asdRatio;
            params.adhdRatio = Math.max(0, remaining);
            document.getElementById('adhd-ratio').value = params.adhdRatio;
            document.getElementById('adhd-percent').textContent = params.adhdRatio + '%';
            
            if (params.distributionModel === 'custom') initSimulation();
        });
        
        // Initialize params for custom distribution
        params.ntRatio = 33;
        params.asdRatio = 33;
        params.adhdRatio = 34;
        
        // Lyrics controls
        document.getElementById('lyrics-abstractness').addEventListener('input', (e) => {
            params.lyricsAbstractness = parseFloat(e.target.value);
            document.getElementById('lyrics-value').textContent = e.target.value;
            trackParameterChange('lyricsAbstractness', params.lyricsAbstractness);
        });
        
        // Lyrics presets with visual feedback
        function setLyricsPreset(type) {
            const value = type === 'concrete' ? 0.1 : 0.9;
            document.getElementById('lyrics-abstractness').value = value;
            document.getElementById('lyrics-value').textContent = value.toFixed(2);
            params.lyricsAbstractness = value;
            trackParameterChange('lyricsAbstractness', value);
            
            // Visual feedback showing which agents prefer this
            agents.forEach(agent => {
                const flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.left = agent.x + 'px';
                flash.style.top = agent.y + 'px';
                flash.style.color = agent.config.color;
                flash.style.pointerEvents = 'none';
                flash.style.fontSize = '18px';
                flash.style.fontWeight = 'bold';
                flash.style.zIndex = '1000';
                
                let response = '';
                if (agent.type === 'NT') {
                    response = type === 'concrete' || type === 'abstract' ? '~' : '✓';
                } else if (agent.type === 'ASD') {
                    response = type === 'concrete' ? '✓' : '✗';
                } else if (agent.type === 'ADHD') {
                    response = type === 'abstract' ? '✓' : '✗';
                }
                
                flash.textContent = response;
                canvas.parentElement.appendChild(flash);
                setTimeout(() => flash.remove(), 1500);
            });
        }
        
        // Initialize
        initSimulation();
        animate();
    </script>
    <!-- Research Study Link -->
    <div style="text-align: center; padding: 40px 20px; margin-top: 50px;">
        <a href="collect.html" style="display: inline-block; background: #00ffcc; color: #000; padding: 12px 30px; border-radius: 25px; text-decoration: none; font-weight: bold;">
            📊 Contribute to Research Study
        </a>
    </div>
        
</body>
</html>
